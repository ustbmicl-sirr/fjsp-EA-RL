# ğŸ­ ç»Ÿä¸€FJSPæ±‚è§£ä¸å¯è§†åŒ–ç³»ç»Ÿ - è½¯ä»¶è®¾è®¡è§„èŒƒ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### ç³»ç»Ÿåç§°
ç»Ÿä¸€æŸ”æ€§ä½œä¸šè½¦é—´è°ƒåº¦é—®é¢˜(FJSP)æ±‚è§£ä¸å¯è§†åŒ–ç³»ç»Ÿ

### ç‰ˆæœ¬ä¿¡æ¯
- **ç‰ˆæœ¬**: v1.0.0
- **å¼€å‘æ—¥æœŸ**: 2025å¹´10æœˆ
- **æŠ€æœ¯æ ˆ**: Python 3.10, Flask, Streamlit, Plotly, NetworkX

### ç³»ç»Ÿç›®æ ‡
æ„å»ºä¸€ä¸ªé›†æˆå¤šç§ç®—æ³•ã€æ”¯æŒå®æ—¶å¯è§†åŒ–çš„FJSPç ”ç©¶å¹³å°ï¼Œèåˆè¿›åŒ–ç®—æ³•ã€å¼ºåŒ–å­¦ä¹ å’Œçº¦æŸç¼–ç¨‹æ–¹æ³•ï¼Œæä¾›å®Œæ•´çš„é—®é¢˜å»ºæ¨¡ã€æ±‚è§£å’Œåˆ†æåŠŸèƒ½ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯å±•ç¤ºå±‚ (Streamlit)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   é—®é¢˜é…ç½®ç•Œé¢   â”‚ â”‚   å¯è§†åŒ–å±•ç¤º     â”‚ â”‚   ç»“æœåˆ†æ       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ HTTP/WebSocket
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   APIæœåŠ¡å±‚ (Flask)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   RESTful API   â”‚ â”‚   WebSocket     â”‚ â”‚   æ–‡ä»¶ç®¡ç†       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ ¸å¿ƒä¸šåŠ¡å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   æ•°æ®é€‚é…å™¨     â”‚ â”‚   ç®—æ³•ç®¡ç†å™¨     â”‚ â”‚   å¯è§†åŒ–å¼•æ“     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç®—æ³•å®ç°å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   è¿›åŒ–ç®—æ³•       â”‚ â”‚   å¼ºåŒ–å­¦ä¹        â”‚ â”‚   çº¦æŸç¼–ç¨‹       â”‚ â”‚
â”‚  â”‚   (NSGA-II,BWO) â”‚ â”‚   (DQN,PPO)     â”‚ â”‚   (OR-Tools)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¨¡å—åŒ–è®¾è®¡

#### 1. æ•°æ®é€‚é…å±‚ (`core/data_adapter.py`)
```python
class UnifiedFJSPInstance:
    - name: str                    # å®ä¾‹åç§°
    - num_jobs: int               # å·¥ä»¶æ•°é‡
    - num_machines: int           # æœºå™¨æ•°é‡
    - operations: List[Operation] # å·¥åºåˆ—è¡¨
    - metadata: Dict[str, Any]    # å…ƒæ•°æ®

class DataAdapter:
    - from_jobshoplib()          # JobShopLibæ ¼å¼è½¬æ¢
    - to_jobshoplib()            # è½¬æ¢ä¸ºJobShopLibæ ¼å¼
    - build_disjunctive_graph()  # æ„å»ºæå–å›¾
    - to_graph_jsp_env()         # Graph-JSP-Envæ ¼å¼
```

#### 2. ç®—æ³•ç®¡ç†å±‚ (`algorithms/unified_solver.py`)
```python
class UnifiedSolverManager:
    - solve_parallel()           # å¹¶è¡Œå¤šç®—æ³•æ±‚è§£
    - add_global_callback()      # æ·»åŠ å…¨å±€å›è°ƒ
    - get_pareto_front()         # è·å–å¸•ç´¯æ‰˜å‰æ²¿

class BaseSolver(ABC):
    - solve()                    # æŠ½è±¡æ±‚è§£æ–¹æ³•
    - add_callback()             # æ·»åŠ å›è°ƒå‡½æ•°
    - notify_callbacks()         # é€šçŸ¥å›è°ƒ
```

#### 3. å¯è§†åŒ–å¼•æ“ (`visualization/unified_visualizer.py`)
```python
class UnifiedVisualizer:
    - plot_gantt_chart()         # ç”˜ç‰¹å›¾å¯è§†åŒ–
    - plot_disjunctive_graph()   # æå–å›¾å¯è§†åŒ–
    - plot_convergence_comparison() # æ”¶æ•›å¯¹æ¯”
    - plot_pareto_front()        # å¸•ç´¯æ‰˜å‰æ²¿
    - create_dashboard()         # ç»¼åˆä»ªè¡¨æ¿
```

## ğŸ¯ æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 1. é—®é¢˜å»ºæ¨¡æ¨¡å—
- **å®ä¾‹ç”Ÿæˆ**: éšæœºç”Ÿæˆã€åŸºå‡†å®ä¾‹åŠ è½½ã€æ–‡ä»¶å¯¼å…¥
- **æ•°æ®éªŒè¯**: çº¦æŸæ£€æŸ¥ã€æ•°æ®å®Œæ•´æ€§éªŒè¯
- **æ ¼å¼è½¬æ¢**: å¤šç§æ•°æ®æ ¼å¼é—´çš„æ— ç¼è½¬æ¢

### 2. ç®—æ³•æ±‚è§£æ¨¡å—
- **è¿›åŒ–ç®—æ³•**: NSGA-II, NSGA-III, BWO, å·®åˆ†è¿›åŒ–
- **å¼ºåŒ–å­¦ä¹ **: DQN, PPO, A3C, SAC
- **çº¦æŸç¼–ç¨‹**: OR-Tools CP-SAT, Gurobi
- **æ··åˆç®—æ³•**: è¿›åŒ–+å¼ºåŒ–å­¦ä¹ , å¤šé˜¶æ®µä¼˜åŒ–

### 3. å®æ—¶ç›‘æ§æ¨¡å—
- **è¿›åº¦è·Ÿè¸ª**: WebSocketå®æ—¶è¿›åº¦æ¨é€
- **æ€§èƒ½ç›‘æ§**: CPUã€å†…å­˜ã€æ”¶æ•›æŒ‡æ ‡
- **å¼‚å¸¸å¤„ç†**: ç®—æ³•å¼‚å¸¸æ£€æµ‹å’Œæ¢å¤

### 4. å¯è§†åŒ–åˆ†ææ¨¡å—
- **è°ƒåº¦æ–¹æ¡ˆ**: äº¤äº’å¼ç”˜ç‰¹å›¾
- **é—®é¢˜ç»“æ„**: æå–å›¾ã€å·¥è‰ºè·¯å¾„å›¾
- **ç®—æ³•åˆ†æ**: æ”¶æ•›æ›²çº¿ã€å¸•ç´¯æ‰˜å‰æ²¿
- **æ€§èƒ½å¯¹æ¯”**: å¤šç®—æ³•ç»¼åˆæ¯”è¾ƒ

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡ä½“ç³»

### ä¸»è¦æ€§èƒ½æŒ‡æ ‡

#### 1. è°ƒåº¦è´¨é‡æŒ‡æ ‡
```python
class ScheduleMetrics:
    makespan: float              # æœ€å¤§å®Œå·¥æ—¶é—´
    total_flowtime: float        # æ€»æµç¨‹æ—¶é—´
    mean_flowtime: float         # å¹³å‡æµç¨‹æ—¶é—´
    total_tardiness: float       # æ€»å»¶è¿Ÿæ—¶é—´
    max_tardiness: float         # æœ€å¤§å»¶è¿Ÿæ—¶é—´
    machine_utilization: List[float]  # æœºå™¨åˆ©ç”¨ç‡
    setup_time: float            # æ€»è®¾ç½®æ—¶é—´
    energy_consumption: float    # èƒ½è€— (æ‰©å±•æŒ‡æ ‡)
```

#### 2. ç®—æ³•æ€§èƒ½æŒ‡æ ‡
```python
class AlgorithmMetrics:
    computation_time: float      # è®¡ç®—æ—¶é—´
    iterations: int              # è¿­ä»£æ¬¡æ•°
    convergence_rate: float      # æ”¶æ•›é€Ÿåº¦
    solution_quality: float      # è§£è´¨é‡
    stability: float             # ç¨³å®šæ€§æŒ‡æ ‡
    memory_usage: float          # å†…å­˜ä½¿ç”¨é‡
    cpu_utilization: float       # CPUåˆ©ç”¨ç‡
```

#### 3. å¤šç›®æ ‡ä¼˜åŒ–æŒ‡æ ‡
```python
class MultiObjectiveMetrics:
    hypervolume: float           # è¶…ä½“ç§¯æŒ‡æ ‡
    spacing: float               # åˆ†å¸ƒå‡åŒ€æ€§
    spread: float                # åˆ†å¸ƒèŒƒå›´
    convergence_metric: float    # æ”¶æ•›æ€§æŒ‡æ ‡
    diversity_metric: float      # å¤šæ ·æ€§æŒ‡æ ‡
    pareto_front_size: int       # å¸•ç´¯æ‰˜å‰æ²¿å¤§å°
```

### æ€§èƒ½è¯„ä¼°æ¡†æ¶
```python
class PerformanceEvaluator:
    def evaluate_single_objective(self, solution, instance):
        """å•ç›®æ ‡æ€§èƒ½è¯„ä¼°"""
        return {
            'makespan': self.calculate_makespan(solution),
            'flowtime': self.calculate_flowtime(solution),
            'utilization': self.calculate_utilization(solution, instance)
        }
    
    def evaluate_multi_objective(self, pareto_front, reference_front=None):
        """å¤šç›®æ ‡æ€§èƒ½è¯„ä¼°"""
        return {
            'hypervolume': self.calculate_hypervolume(pareto_front),
            'spacing': self.calculate_spacing(pareto_front),
            'convergence': self.calculate_convergence(pareto_front, reference_front)
        }
    
    def benchmark_algorithms(self, algorithms, instances):
        """ç®—æ³•åŸºå‡†æµ‹è¯•"""
        results = {}
        for alg in algorithms:
            for inst in instances:
                result = alg.solve(inst)
                results[f"{alg.name}_{inst.name}"] = self.evaluate_single_objective(result, inst)
        return results
```

## ğŸ¯ å¤šç›®æ ‡å¸•ç´¯æ‰˜æœ€ä¼˜æ‰©å±•è®¾è®¡

### 1. å¤šç›®æ ‡ä¼˜åŒ–æ¡†æ¶

#### ç›®æ ‡å‡½æ•°å®šä¹‰
```python
class MultiObjectiveFunction:
    def __init__(self):
        self.objectives = {
            'makespan': self.minimize_makespan,
            'flowtime': self.minimize_total_flowtime,
            'tardiness': self.minimize_total_tardiness,
            'energy': self.minimize_energy_consumption,
            'cost': self.minimize_total_cost,
            'quality': self.maximize_quality,
            'flexibility': self.maximize_flexibility
        }
    
    def evaluate(self, solution, instance, objective_weights=None):
        """å¤šç›®æ ‡è¯„ä¼°"""
        values = {}
        for name, func in self.objectives.items():
            values[name] = func(solution, instance)
        
        if objective_weights:
            # åŠ æƒæ±‚å’Œæ–¹æ³•
            return sum(w * values[obj] for obj, w in objective_weights.items())
        else:
            # è¿”å›ç›®æ ‡å‘é‡
            return list(values.values())
```

#### å¸•ç´¯æ‰˜å‰æ²¿ç®¡ç†
```python
class ParetoFrontManager:
    def __init__(self):
        self.solutions = []
        self.objectives = []
        self.dominated_count = []
    
    def add_solution(self, solution, objectives):
        """æ·»åŠ è§£åˆ°å¸•ç´¯æ‰˜å‰æ²¿"""
        is_dominated = False
        dominated_indices = []
        
        for i, existing_obj in enumerate(self.objectives):
            dominance = self.compare_solutions(objectives, existing_obj)
            if dominance == -1:  # æ–°è§£è¢«æ”¯é…
                is_dominated = True
                break
            elif dominance == 1:  # æ–°è§£æ”¯é…ç°æœ‰è§£
                dominated_indices.append(i)
        
        if not is_dominated:
            # ç§»é™¤è¢«æ”¯é…çš„è§£
            for i in reversed(dominated_indices):
                del self.solutions[i]
                del self.objectives[i]
            
            # æ·»åŠ æ–°è§£
            self.solutions.append(solution)
            self.objectives.append(objectives)
    
    def get_pareto_front(self):
        """è·å–å½“å‰å¸•ç´¯æ‰˜å‰æ²¿"""
        return list(zip(self.solutions, self.objectives))
    
    def compare_solutions(self, obj1, obj2):
        """æ¯”è¾ƒä¸¤ä¸ªè§£çš„æ”¯é…å…³ç³»"""
        better_count = 0
        worse_count = 0
        
        for v1, v2 in zip(obj1, obj2):
            if v1 < v2:  # å‡è®¾æœ€å°åŒ–
                better_count += 1
            elif v1 > v2:
                worse_count += 1
        
        if better_count > 0 and worse_count == 0:
            return 1   # obj1 æ”¯é… obj2
        elif worse_count > 0 and better_count == 0:
            return -1  # obj2 æ”¯é… obj1
        else:
            return 0   # éæ”¯é…å…³ç³»
```

### 2. å¤šç›®æ ‡ç®—æ³•æ‰©å±•

#### NSGA-II æ‰©å±•å®ç°
```python
class MultiObjectiveNSGAII(BaseSolver):
    def __init__(self, population_size=100, max_generations=500):
        super().__init__("MO-NSGA-II")
        self.population_size = population_size
        self.max_generations = max_generations
        self.pareto_manager = ParetoFrontManager()
    
    def solve(self, instance, objectives=['makespan', 'flowtime', 'tardiness']):
        """å¤šç›®æ ‡NSGA-IIæ±‚è§£"""
        population = self.initialize_population(instance)
        
        for generation in range(self.max_generations):
            # è¯„ä¼°ç›®æ ‡å‡½æ•°
            objective_values = []
            for individual in population:
                values = self.evaluate_objectives(individual, instance, objectives)
                objective_values.append(values)
                self.pareto_manager.add_solution(individual, values)
            
            # éæ”¯é…æ’åº
            fronts = self.non_dominated_sort(population, objective_values)
            
            # æ‹¥æŒ¤è·ç¦»è®¡ç®—
            for front in fronts:
                self.calculate_crowding_distance(front, objective_values)
            
            # é€‰æ‹©å’Œå˜å¼‚
            population = self.selection_and_variation(fronts)
            
            # å›è°ƒé€šçŸ¥
            self.notify_callbacks({
                'generation': generation,
                'pareto_front_size': len(self.pareto_manager.solutions),
                'hypervolume': self.calculate_hypervolume()
            })
        
        return self.pareto_manager.get_pareto_front()
```

#### å¤šç›®æ ‡å¼ºåŒ–å­¦ä¹ æ‰©å±•
```python
class MultiObjectiveRL(BaseSolver):
    def __init__(self, objectives=['makespan', 'flowtime']):
        super().__init__("MO-RL")
        self.objectives = objectives
        self.scalarization_methods = {
            'weighted_sum': self.weighted_sum_scalarization,
            'tchebycheff': self.tchebycheff_scalarization,
            'pbi': self.penalty_boundary_intersection
        }
    
    def solve(self, instance, method='weighted_sum', reference_point=None):
        """å¤šç›®æ ‡å¼ºåŒ–å­¦ä¹ æ±‚è§£"""
        # ç”Ÿæˆæƒé‡å‘é‡
        weight_vectors = self.generate_weight_vectors(len(self.objectives))
        pareto_solutions = []
        
        for weights in weight_vectors:
            # æ ‡é‡åŒ–å¤šç›®æ ‡é—®é¢˜
            scalarized_reward = self.scalarization_methods[method]
            
            # è®­ç»ƒRLæ™ºèƒ½ä½“
            agent = self.create_agent(instance, scalarized_reward, weights)
            solution = agent.train_and_solve()
            
            # è¯„ä¼°åŸå§‹ç›®æ ‡
            objectives = self.evaluate_objectives(solution, instance)
            pareto_solutions.append((solution, objectives))
        
        # æå–å¸•ç´¯æ‰˜å‰æ²¿
        return self.extract_pareto_front(pareto_solutions)
```

### 3. äº¤äº’å¼å¤šç›®æ ‡ä¼˜åŒ–

#### åå¥½å¼•å¯¼ä¼˜åŒ–
```python
class InteractiveMultiObjective:
    def __init__(self, solver):
        self.solver = solver
        self.user_preferences = {}
        self.aspiration_levels = {}
    
    def set_user_preferences(self, preferences):
        """è®¾ç½®ç”¨æˆ·åå¥½"""
        self.user_preferences = preferences
        # preferences = {
        #     'makespan': {'weight': 0.4, 'aspiration': 100},
        #     'flowtime': {'weight': 0.3, 'aspiration': 500},
        #     'cost': {'weight': 0.3, 'aspiration': 1000}
        # }
    
    def interactive_solve(self, instance):
        """äº¤äº’å¼æ±‚è§£"""
        # åˆå§‹æ±‚è§£è·å¾—å¸•ç´¯æ‰˜å‰æ²¿
        initial_front = self.solver.solve(instance)
        
        # å±•ç¤ºç»™ç”¨æˆ·å¹¶è·å–åé¦ˆ
        selected_region = self.present_to_user(initial_front)
        
        # åŸºäºç”¨æˆ·åé¦ˆè°ƒæ•´æœç´¢
        refined_front = self.refine_search(instance, selected_region)
        
        return refined_front
    
    def present_to_user(self, pareto_front):
        """å‘ç”¨æˆ·å±•ç¤ºå¸•ç´¯æ‰˜å‰æ²¿"""
        # å¯è§†åŒ–å¸•ç´¯æ‰˜å‰æ²¿
        self.visualize_pareto_front(pareto_front)
        
        # è·å–ç”¨æˆ·é€‰æ‹©çš„æ„Ÿå…´è¶£åŒºåŸŸ
        return self.get_user_selection()
```

### 4. å¯è§†åŒ–æ‰©å±•

#### å¤šç›®æ ‡å¯è§†åŒ–ç»„ä»¶
```python
class MultiObjectiveVisualizer(UnifiedVisualizer):
    def plot_pareto_front_2d(self, pareto_front, objectives):
        """2Då¸•ç´¯æ‰˜å‰æ²¿å¯è§†åŒ–"""
        fig = go.Figure()
        
        x_values = [sol[1][0] for sol in pareto_front]  # ç¬¬ä¸€ä¸ªç›®æ ‡
        y_values = [sol[1][1] for sol in pareto_front]  # ç¬¬äºŒä¸ªç›®æ ‡
        
        fig.add_trace(go.Scatter(
            x=x_values, y=y_values,
            mode='markers+lines',
            name='å¸•ç´¯æ‰˜å‰æ²¿',
            marker=dict(size=8, color='red')
        ))
        
        fig.update_layout(
            title='å¸•ç´¯æ‰˜å‰æ²¿',
            xaxis_title=objectives[0],
            yaxis_title=objectives[1]
        )
        
        return fig
    
    def plot_pareto_front_3d(self, pareto_front, objectives):
        """3Då¸•ç´¯æ‰˜å‰æ²¿å¯è§†åŒ–"""
        fig = go.Figure()
        
        x_values = [sol[1][0] for sol in pareto_front]
        y_values = [sol[1][1] for sol in pareto_front]
        z_values = [sol[1][2] for sol in pareto_front]
        
        fig.add_trace(go.Scatter3d(
            x=x_values, y=y_values, z=z_values,
            mode='markers',
            name='å¸•ç´¯æ‰˜å‰æ²¿',
            marker=dict(size=5, color='blue')
        ))
        
        fig.update_layout(
            title='3Då¸•ç´¯æ‰˜å‰æ²¿',
            scene=dict(
                xaxis_title=objectives[0],
                yaxis_title=objectives[1],
                zaxis_title=objectives[2]
            )
        )
        
        return fig
    
    def plot_parallel_coordinates(self, pareto_front, objectives):
        """å¹³è¡Œåæ ‡å›¾"""
        data = []
        for sol in pareto_front:
            data.append(sol[1])  # ç›®æ ‡å€¼
        
        df = pd.DataFrame(data, columns=objectives)
        
        fig = go.Figure(data=go.Parcoords(
            line=dict(color=df.index, colorscale='Viridis'),
            dimensions=[dict(label=obj, values=df[obj]) for obj in objectives]
        ))
        
        fig.update_layout(title='å¸•ç´¯æ‰˜è§£é›†å¹³è¡Œåæ ‡å›¾')
        return fig
```

## ğŸ”§ æŠ€æœ¯å®ç°ç»†èŠ‚

### 1. å¹¶å‘å¤„ç†
- **å¤šè¿›ç¨‹**: ç®—æ³•å¹¶è¡Œæ‰§è¡Œ
- **å¼‚æ­¥IO**: WebSocketå®æ—¶é€šä¿¡
- **çº¿ç¨‹æ± **: å¯è§†åŒ–ä»»åŠ¡å¤„ç†

### 2. å†…å­˜ç®¡ç†
- **å¯¹è±¡æ± **: é‡ç”¨é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡
- **å»¶è¿ŸåŠ è½½**: æŒ‰éœ€åŠ è½½å¤§å‹æ•°æ®
- **ç¼“å­˜æœºåˆ¶**: è®¡ç®—ç»“æœç¼“å­˜

### 3. æ‰©å±•æ€§è®¾è®¡
- **æ’ä»¶æ¶æ„**: æ–°ç®—æ³•åŠ¨æ€åŠ è½½
- **é…ç½®é©±åŠ¨**: å‚æ•°å¤–éƒ¨åŒ–é…ç½®
- **æ¥å£æ ‡å‡†åŒ–**: ç»Ÿä¸€çš„ç®—æ³•æ¥å£

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç®—æ³•ä¼˜åŒ–
- **æ—©åœæœºåˆ¶**: æ”¶æ•›æ£€æµ‹
- **è‡ªé€‚åº”å‚æ•°**: åŠ¨æ€è°ƒæ•´ç®—æ³•å‚æ•°
- **æ··åˆç­–ç•¥**: å¤šç®—æ³•ååŒä¼˜åŒ–

### 2. ç³»ç»Ÿä¼˜åŒ–
- **æ•°æ®ç»“æ„**: é«˜æ•ˆçš„æ•°æ®è¡¨ç¤º
- **è®¡ç®—ä¼˜åŒ–**: å‘é‡åŒ–è®¡ç®—
- **IOä¼˜åŒ–**: æ‰¹é‡æ•°æ®å¤„ç†

### 3. å¯è§†åŒ–ä¼˜åŒ–
- **æ¸è¿›æ¸²æŸ“**: å¤§æ•°æ®é›†åˆ†æ‰¹æ¸²æŸ“
- **LODæŠ€æœ¯**: å¤šå±‚æ¬¡ç»†èŠ‚
- **ç¼“å­˜ç­–ç•¥**: å›¾è¡¨ç»“æœç¼“å­˜

## ğŸ¯ æœªæ¥æ‰©å±•æ–¹å‘

### 1. ç®—æ³•æ‰©å±•
- **æ·±åº¦å¼ºåŒ–å­¦ä¹ **: Transformer-based RL
- **è”é‚¦å­¦ä¹ **: åˆ†å¸ƒå¼ä¼˜åŒ–
- **é‡å­ç®—æ³•**: é‡å­é€€ç«ä¼˜åŒ–

### 2. åŠŸèƒ½æ‰©å±•
- **äº‘ç«¯éƒ¨ç½²**: å¾®æœåŠ¡æ¶æ„
- **ç§»åŠ¨ç«¯**: å“åº”å¼è®¾è®¡
- **åä½œåŠŸèƒ½**: å¤šç”¨æˆ·ååŒ

### 3. åº”ç”¨æ‰©å±•
- **å®æ—¶è°ƒåº¦**: åŠ¨æ€é‡è°ƒåº¦
- **é¢„æµ‹æ€§ç»´æŠ¤**: è®¾å¤‡æ•…éšœé¢„æµ‹
- **ä¾›åº”é“¾ä¼˜åŒ–**: ç«¯åˆ°ç«¯ä¼˜åŒ–

## ğŸ“Š ç³»ç»Ÿæ€§èƒ½åŸºå‡†æµ‹è¯•

### æµ‹è¯•ç¯å¢ƒè§„æ ¼
```yaml
ç¡¬ä»¶é…ç½®:
  CPU: Intel i7-12700K (12æ ¸24çº¿ç¨‹)
  å†…å­˜: 32GB DDR4-3200
  å­˜å‚¨: 1TB NVMe SSD
  GPU: NVIDIA RTX 3080 (å¯é€‰)

è½¯ä»¶ç¯å¢ƒ:
  æ“ä½œç³»ç»Ÿ: macOS 13.0 / Ubuntu 22.04
  Python: 3.10+
  ä¾èµ–åº“: è§requirements.txt
```

### æ€§èƒ½åŸºå‡†æ•°æ®
```python
# æ ‡å‡†æµ‹è¯•å®ä¾‹æ€§èƒ½
BENCHMARK_RESULTS = {
    'ft06': {  # 6å·¥ä»¶Ã—6æœºå™¨
        'makespan_optimal': 55,
        'algorithms': {
            'OR-Tools': {'time': 0.12, 'makespan': 55, 'gap': 0.0},
            'NSGA-II': {'time': 2.34, 'makespan': 57, 'gap': 3.6},
            'BWO': {'time': 1.89, 'makespan': 56, 'gap': 1.8},
            'DQN': {'time': 15.67, 'makespan': 58, 'gap': 5.4}
        }
    },
    'la21': {  # 15å·¥ä»¶Ã—10æœºå™¨
        'makespan_optimal': 1046,
        'algorithms': {
            'OR-Tools': {'time': 45.23, 'makespan': 1046, 'gap': 0.0},
            'NSGA-II': {'time': 12.45, 'makespan': 1089, 'gap': 4.1},
            'BWO': {'time': 8.76, 'makespan': 1067, 'gap': 2.0},
            'DQN': {'time': 89.34, 'makespan': 1123, 'gap': 7.4}
        }
    }
}
```

### å¯æ‰©å±•æ€§æµ‹è¯•
```python
SCALABILITY_TEST = {
    'small': {'jobs': 10, 'machines': 5, 'avg_time': 1.2},
    'medium': {'jobs': 50, 'machines': 20, 'avg_time': 15.6},
    'large': {'jobs': 100, 'machines': 50, 'avg_time': 156.8},
    'xlarge': {'jobs': 500, 'machines': 100, 'avg_time': 1247.3}
}
```

## ğŸ¯ å¤šç›®æ ‡ä¼˜åŒ–æ·±åº¦è®¾è®¡

### 1. ç›®æ ‡å‡½æ•°æ•°å­¦æ¨¡å‹

#### åŸºç¡€ç›®æ ‡å‡½æ•°
```python
class ObjectiveFunctions:
    @staticmethod
    def makespan(schedule, instance):
        """æœ€å¤§å®Œå·¥æ—¶é—´ - ä¸»è¦ç›®æ ‡"""
        return max(job.completion_time for job in schedule.jobs)

    @staticmethod
    def total_flowtime(schedule, instance):
        """æ€»æµç¨‹æ—¶é—´ - æ•ˆç‡ç›®æ ‡"""
        return sum(job.completion_time - job.release_time
                  for job in schedule.jobs)

    @staticmethod
    def total_tardiness(schedule, instance):
        """æ€»å»¶è¿Ÿæ—¶é—´ - å‡†æ—¶æ€§ç›®æ ‡"""
        return sum(max(0, job.completion_time - job.due_date)
                  for job in schedule.jobs)

    @staticmethod
    def energy_consumption(schedule, instance):
        """èƒ½è€— - ç»¿è‰²åˆ¶é€ ç›®æ ‡"""
        total_energy = 0
        for machine in schedule.machines:
            # åŠ å·¥èƒ½è€—
            processing_energy = sum(op.processing_time * machine.power_rating
                                  for op in machine.operations)
            # ç©ºé—²èƒ½è€—
            idle_energy = machine.idle_time * machine.idle_power
            total_energy += processing_energy + idle_energy
        return total_energy

    @staticmethod
    def setup_cost(schedule, instance):
        """è®¾ç½®æˆæœ¬ - ç»æµç›®æ ‡"""
        return sum(op.setup_cost for machine in schedule.machines
                  for op in machine.operations)
```

#### é«˜çº§ç›®æ ‡å‡½æ•°
```python
class AdvancedObjectives:
    @staticmethod
    def robustness(schedule, instance, uncertainty_scenarios):
        """é²æ£’æ€§ - ä¸ç¡®å®šæ€§å¤„ç†"""
        worst_case_makespan = 0
        for scenario in uncertainty_scenarios:
            perturbed_schedule = schedule.apply_uncertainty(scenario)
            makespan = ObjectiveFunctions.makespan(perturbed_schedule, instance)
            worst_case_makespan = max(worst_case_makespan, makespan)
        return worst_case_makespan

    @staticmethod
    def flexibility(schedule, instance):
        """æŸ”æ€§åº¦ - é€‚åº”æ€§ç›®æ ‡"""
        flexibility_score = 0
        for job in schedule.jobs:
            for operation in job.operations:
                # æœºå™¨é€‰æ‹©çš„å¤šæ ·æ€§
                machine_options = len(operation.alternative_machines)
                flexibility_score += machine_options
        return flexibility_score / len(schedule.operations)

    @staticmethod
    def quality_index(schedule, instance):
        """è´¨é‡æŒ‡æ•° - äº§å“è´¨é‡ç›®æ ‡"""
        quality_score = 0
        for job in schedule.jobs:
            for operation in job.operations:
                machine = operation.assigned_machine
                quality_score += machine.quality_rating * operation.processing_time
        return quality_score / schedule.total_processing_time
```

### 2. å¸•ç´¯æ‰˜å‰æ²¿ç®—æ³•å®ç°

#### å¿«é€Ÿéæ”¯é…æ’åº
```python
class FastNonDominatedSort:
    def __init__(self):
        self.fronts = []

    def sort(self, population, objectives):
        """å¿«é€Ÿéæ”¯é…æ’åºç®—æ³•"""
        n = len(population)
        domination_count = [0] * n  # è¢«æ”¯é…æ¬¡æ•°
        dominated_solutions = [[] for _ in range(n)]  # æ”¯é…çš„è§£é›†

        # è®¡ç®—æ”¯é…å…³ç³»
        for i in range(n):
            for j in range(n):
                if i != j:
                    dominance = self.dominates(objectives[i], objectives[j])
                    if dominance == 1:  # iæ”¯é…j
                        dominated_solutions[i].append(j)
                    elif dominance == -1:  # jæ”¯é…i
                        domination_count[i] += 1

        # æ„å»ºå‰æ²¿
        current_front = []
        for i in range(n):
            if domination_count[i] == 0:
                current_front.append(i)

        front_index = 0
        self.fronts = [current_front]

        while len(current_front) > 0:
            next_front = []
            for i in current_front:
                for j in dominated_solutions[i]:
                    domination_count[j] -= 1
                    if domination_count[j] == 0:
                        next_front.append(j)

            if len(next_front) > 0:
                self.fronts.append(next_front)
            current_front = next_front
            front_index += 1

        return self.fronts

    def dominates(self, obj1, obj2):
        """åˆ¤æ–­obj1æ˜¯å¦æ”¯é…obj2"""
        better = False
        for v1, v2 in zip(obj1, obj2):
            if v1 > v2:  # å‡è®¾æœ€å°åŒ–é—®é¢˜
                return -1  # obj1è¢«obj2æ”¯é…
            elif v1 < v2:
                better = True

        return 1 if better else 0  # 1è¡¨ç¤ºæ”¯é…ï¼Œ0è¡¨ç¤ºéæ”¯é…
```

#### æ‹¥æŒ¤è·ç¦»è®¡ç®—
```python
class CrowdingDistance:
    @staticmethod
    def calculate(front_indices, objectives):
        """è®¡ç®—æ‹¥æŒ¤è·ç¦»"""
        if len(front_indices) <= 2:
            return [float('inf')] * len(front_indices)

        distances = [0.0] * len(front_indices)
        num_objectives = len(objectives[0])

        for obj_idx in range(num_objectives):
            # æŒ‰å½“å‰ç›®æ ‡æ’åº
            sorted_indices = sorted(front_indices,
                                  key=lambda x: objectives[x][obj_idx])

            # è¾¹ç•Œç‚¹è®¾ä¸ºæ— ç©·å¤§
            distances[0] = float('inf')
            distances[-1] = float('inf')

            # è®¡ç®—ç›®æ ‡èŒƒå›´
            obj_range = (objectives[sorted_indices[-1]][obj_idx] -
                        objectives[sorted_indices[0]][obj_idx])

            if obj_range == 0:
                continue

            # è®¡ç®—ä¸­é—´ç‚¹çš„æ‹¥æŒ¤è·ç¦»
            for i in range(1, len(sorted_indices) - 1):
                distance = (objectives[sorted_indices[i+1]][obj_idx] -
                           objectives[sorted_indices[i-1]][obj_idx]) / obj_range
                distances[i] += distance

        return distances
```

### 3. å¤šç›®æ ‡æ€§èƒ½æŒ‡æ ‡

#### è¶…ä½“ç§¯æŒ‡æ ‡
```python
class HypervolumeCalculator:
    def __init__(self, reference_point):
        self.reference_point = reference_point

    def calculate(self, pareto_front):
        """è®¡ç®—è¶…ä½“ç§¯æŒ‡æ ‡"""
        if not pareto_front:
            return 0.0

        # å¯¹äº2Dæƒ…å†µçš„å¿«é€Ÿè®¡ç®—
        if len(pareto_front[0]) == 2:
            return self._calculate_2d(pareto_front)
        else:
            # ä½¿ç”¨WFGç®—æ³•è®¡ç®—é«˜ç»´è¶…ä½“ç§¯
            return self._calculate_wfg(pareto_front)

    def _calculate_2d(self, front):
        """2Dè¶…ä½“ç§¯è®¡ç®—"""
        # æŒ‰ç¬¬ä¸€ä¸ªç›®æ ‡æ’åº
        sorted_front = sorted(front, key=lambda x: x[0])

        hypervolume = 0.0
        prev_x = self.reference_point[0]

        for point in sorted_front:
            if point[1] < self.reference_point[1]:
                width = prev_x - point[0]
                height = self.reference_point[1] - point[1]
                hypervolume += width * height
                prev_x = point[0]

        return hypervolume
```

#### åˆ†å¸ƒæ€§æŒ‡æ ‡
```python
class DistributionMetrics:
    @staticmethod
    def spacing(pareto_front):
        """åˆ†å¸ƒå‡åŒ€æ€§æŒ‡æ ‡"""
        if len(pareto_front) < 2:
            return 0.0

        distances = []
        for i, point1 in enumerate(pareto_front):
            min_dist = float('inf')
            for j, point2 in enumerate(pareto_front):
                if i != j:
                    dist = sum((v1 - v2) ** 2 for v1, v2 in zip(point1, point2)) ** 0.5
                    min_dist = min(min_dist, dist)
            distances.append(min_dist)

        mean_dist = sum(distances) / len(distances)
        variance = sum((d - mean_dist) ** 2 for d in distances) / len(distances)

        return variance ** 0.5

    @staticmethod
    def spread(pareto_front):
        """åˆ†å¸ƒèŒƒå›´æŒ‡æ ‡"""
        if len(pareto_front) < 2:
            return 0.0

        num_objectives = len(pareto_front[0])
        ranges = []

        for obj_idx in range(num_objectives):
            values = [point[obj_idx] for point in pareto_front]
            ranges.append(max(values) - min(values))

        return sum(ranges) / num_objectives
```

## ğŸ”§ é«˜çº§æŠ€æœ¯å®ç°

### 1. è‡ªé€‚åº”ç®—æ³•æ¡†æ¶
```python
class AdaptiveAlgorithmFramework:
    def __init__(self):
        self.performance_history = {}
        self.algorithm_pool = {}
        self.selection_strategy = 'ucb'  # Upper Confidence Bound

    def register_algorithm(self, name, algorithm_class):
        """æ³¨å†Œç®—æ³•åˆ°æ± ä¸­"""
        self.algorithm_pool[name] = {
            'class': algorithm_class,
            'performance': [],
            'usage_count': 0,
            'success_rate': 0.0
        }

    def select_algorithm(self, instance_features):
        """åŸºäºå®ä¾‹ç‰¹å¾é€‰æ‹©æœ€ä½³ç®—æ³•"""
        if self.selection_strategy == 'ucb':
            return self._ucb_selection(instance_features)
        elif self.selection_strategy == 'thompson':
            return self._thompson_sampling(instance_features)
        else:
            return self._epsilon_greedy(instance_features)

    def update_performance(self, algorithm_name, performance_metrics):
        """æ›´æ–°ç®—æ³•æ€§èƒ½è®°å½•"""
        alg_info = self.algorithm_pool[algorithm_name]
        alg_info['performance'].append(performance_metrics)
        alg_info['usage_count'] += 1

        # è®¡ç®—æˆåŠŸç‡ï¼ˆåŸºäºè§£è´¨é‡é˜ˆå€¼ï¼‰
        good_solutions = sum(1 for p in alg_info['performance']
                           if p['quality'] > 0.8)
        alg_info['success_rate'] = good_solutions / alg_info['usage_count']
```

### 2. å®æ—¶ä¼˜åŒ–å¼•æ“
```python
class RealTimeOptimizationEngine:
    def __init__(self):
        self.active_jobs = {}
        self.machine_status = {}
        self.event_queue = []
        self.rescheduling_triggers = {
            'job_arrival': self.handle_job_arrival,
            'machine_breakdown': self.handle_machine_breakdown,
            'job_completion': self.handle_job_completion,
            'priority_change': self.handle_priority_change
        }

    def start_real_time_scheduling(self, initial_schedule):
        """å¯åŠ¨å®æ—¶è°ƒåº¦"""
        self.current_schedule = initial_schedule
        self.simulation_time = 0

        while self.has_active_jobs():
            # å¤„ç†äº‹ä»¶
            event = self.get_next_event()
            self.simulation_time = event.time

            # è§¦å‘é‡è°ƒåº¦æ£€æŸ¥
            if self.should_reschedule(event):
                new_schedule = self.reschedule(event)
                self.update_schedule(new_schedule)

            # æ‰§è¡Œäº‹ä»¶
            self.execute_event(event)

    def should_reschedule(self, event):
        """åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è°ƒåº¦"""
        if event.type in ['machine_breakdown', 'urgent_job']:
            return True

        # åŸºäºæ€§èƒ½é˜ˆå€¼åˆ¤æ–­
        current_performance = self.evaluate_current_performance()
        return current_performance < self.performance_threshold
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2025å¹´10æœˆ7æ—¥
**ç»´æŠ¤è€…**: FJSPå¼€å‘å›¢é˜Ÿ
